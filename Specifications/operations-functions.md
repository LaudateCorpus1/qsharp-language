---
title: Operations and functions in Q#
description: How to define and call operations and functions, as well the controlled and adjoint operation specializations.
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.operationsfunctions
---

# Operations and Functions in Q#

## Defining New Operations

## Controlled and Adjoint Operations

If an operation implements a unitary transformation, as is the case for many operations in Q#, then it is possible to define how the operation acts when *adjointed* or *controlled*. 
An *adjoint* specialization of an operation specifies how the "inverse" of the operation acts, while a *controlled* specialization specifies how an operation acts when its application is conditioned on the state of a particular quantum register.

Adjoints of quantum operations are crucial to many aspects of quantum computing. 
Further below, in the [Conjugations](#conjugations) section, you will find one such situation discussed alongside a useful Q# programming technique.

The controlled version of an operation is a new operation that effectively applies the base operation only if all of the control qubits are in a specified state.
If the control qubits are in superposition, then the base operation is applied coherently to the appropriate part of the superposition.
Thus, controlled operations are often used to generate entanglement.

Naturally, a *controlled adjoint* specialization could exist as well, specifying the controlled application of an operation's adjoint.

> [!NOTE]
> If $U$ is the unitary transformation implemented by an operation `U`, then `Adjoint U` represents the unitary transformation $U^\dagger$, which is the complex conjugate transpose.
> Successively applying an operation and then its adjoint to a state leaves the state unchanged, as illustrated by the fact that $UU^\dagger = U^\dagger U = \id$, the identity matrix.
> The unitary representation of a controlled operation is slightly more nuanced, but you can find more details at [Quantum computing concepts: multiple qubits](xref:microsoft.quantum.concepts.multiple-qubits).

The following section describes how to call these various specializations in your Q# code.
Below, we detail how to define operations to support them.

### Calling operation specializations

A *functor* in Q# is a factory that defines a new operation from another operation.
The two standard functors in Q# are `Adjoint` and `Controlled`.

Functors have access to the implementation of the base operation when defining the implementation of the new operation.
Thus, functors can perform more complex functions than traditional higher-level functions. 
Functors do not have a representation in the Q# type system. 
It is thus currently not possible to bind them to a variable or pass them as arguments. 

A functor is used by applying it to an operation, returning a new operation.
For example, the operation that results from applying the `Adjoint` functor to the `Y` operation is written as `Adjoint Y`.
The new operation may then be invoked like any other operation.
For an operation to support application of the `Adjoint` and/or `Controlled` functors, its return type necessarily needs to be `Unit`. 

## Defining Controlled and Adjoint Implementations

In the first operation declaration examples above, the operations `BitFlip` and `DecodeSuperdense` were defined with signatures `(Qubit => Unit)` and `((Qubit, Qubit) => (Result, Result))`, respectively.
As `DecodeSuperdense` includes measurements, it is not a unitary operation, and therefore neither controlled not adjoint specializations could exist (recall the related requirement that such an operation return `Unit`).
However, as `BitFlip` simply performs the unitary <xref:microsoft.quantum.intrinsic.x> operation, we could have defined it with both specializations.

Each specialization can either be *implicitly* or *explicitly* defined.

### Implicitly specifying implementations

In this case, the body of the operation declaration consists solely of the default implementation. 
For example:

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit 
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```
Here, the corresponding implementation for each such implicitly declared specialization is automatically generated by the compiler, to be performed if the `Adjoint` or `Controlled` functors are used.

So, a call of `Adjoint PrepareEntangledPair` would result in the compiler implementing the adjoint of `CNOT` and then the adjoint of `H`.
These individual operations are both self-adjoint, so the resulting `Adjoint PrepareEntangledPair` operation would simply consist of applying `CNOT(here, there)` and then `H(here)`.
Hence we can use this to write the `DecodeSuperdense` example above more compactly, by using the adjoint of `PrepareEntangledPair` to transform the entangled state back into an unentangled pair of qubits:

```qsharp
operation DecodeSuperdense(here : Qubit, there : Qubit) : (Result, Result) {
    Adjoint PrepareEntangledPair(there, here);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```

The annotation with the operation characteristics in the declaration is useful to ensure that the compiler auto-generates other specializations based on the default implementation. 

There are a number of important limitations to consider when designing operations for use with functors.
Most critically, specializations for an operation that uses the output value of any other operation *cannot* be auto-generated by the compiler, as it is ambiguous how to reorder the statements in such an operation to obtain the same effect.

Therefore, it is often useful to explicitly specify the various implementations.

### Explicitly specifying implementations

In the case where the implementation cannot be generated by the compiler, it can be explicitly specified. 
Such explicit specialization declarations can consist of a suitable *generation directive* or a user-defined implementation.
Here we provide the full range of possibilities, with examples following below.


#### Explicit specialization declarations

Q# operations may contain the following explicit specialization declarations:

- The `body` specialization specifies the implementation of the operation with no functors applied.
- The `adjoint` specialization specifies the implementation of the operation with the `Adjoint` functor applied.
- The `controlled` specialization specifies the implementation of the operation with the `Controlled` functor applied.
- The `controlled adjoint` specialization specifies the implementation of the
  operation with both the `Adjoint` and `Controlled` functors applied.
  This specialization can also be named `adjoint controlled`, since the two functors commute.


An operation specialization consists of the specialization tag (e.g. `body`, or `adjoint`, etc.) followed by one of:

- An explicit declaration as described below.
- A *directive* that tells the compiler *how* to generate the specialization, one of:
  - `intrinsic`, which indicates that the specialization is provided by the target machine.
  - `distribute`, which may be used with the `controlled` and `controlled adjoint` specializations.
    When used with `controlled`, it indicates that the compiler should compute the specialization by applying `Controlled` to all of the operations in the `body`.
    When used with `controlled adjoint`, it indicates that the compiler should compute the specialization by applying `Controlled` to all of the operations in the `adjoint` specialization.
  - `invert`, which indicates that the compiler should compute the `adjoint` specialization by inverting the `body`, i.e. reversing the order of operations and applying the adjoint to each one.
    When used with `adjoint controlled`, this indicates that the compiler should compute the specialization by inverting the `controlled` specialization.
  - `self`, to indicate that the adjoint specialization is the the same as the `body` specialization.
    This is legal for the `adjoint` and `adjoint controlled` specializations.
    For `adjoint controlled`, `self` implies that the `adjoint controlled` specialization is the same as the `controlled` specialization.
  - `auto`, to indicate that the compiler should select an appropriate directive to apply.
    `auto` may not be used for the `body` specialization.

The directives and `auto` all require a closing semi-colon `;`.
The `auto` directive resolves to the following generation directive if an explicit declaration of the `body` is provided:

- The `adjoint` specialization is generated according to the directive `invert`.
- The `controlled` specialization is generated according to the directive `distribute`.
- The `adjoint controlled` specialization is generated according to the directive `invert` if an explicit
  declaration for `controlled` is given but not one for `adjoint`, and
  `distribute` otherwise.

> [!TIP]   
> If an operation is self-adjoint, explicitly specify either the adjoint or the controlled adjoint specialization via the generation directive `self` to allow the compiler to make use of that information for optimization purposes.

A specialization declaration containing a user defined implementation consists of an argument tuple followed by a statement block with the Q# code that implements the specialization.
In the argument list, `...` is used to represent the arguments declared for the operation as a whole.
For `body` and `adjoint`, the argument list should always be `(...)`; for `controlled` and `adjoint controlled`, the argument list should be a symbol that represents the array of control qubits, followed by `...`, enclosed in parentheses; for example, `(controls,...)`.

### Examples

An operation declaration might be as simple as the following, which defines the primitive Pauli X operation:

```qsharp
operation X (qubit : Qubit) : Unit
is Adj + Ctl {
    body intrinsic;
    adjoint self;
}
```
Note that the adjoint of the Pauli X operation is defined with the directive `self` because by definition `X` is its own inverse.

The code in `PrepareEntangledPair` above for example is equivalent to the code below containing explicit specialization declarations: 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit 
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    adjoint auto; // auto-generate adjoint specialization
    controlled auto; // auto-generate controlled specialization
    controlled adjoint auto; // auto-generate controlled adjoint specialization
}
```
The keyword `auto` indicates that the compiler should determine how to generate the specialization implementation.

#### User-defined specialization implementation

If the compiler cannot generate the implementation for a certain specialization automatically, or if a more efficient implementation can be given, then the implementation may also be manually defined.

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    controlled (cs, ...) { // user defined implementation for the controlled specialization
        Controlled H(cs, here);
        Controlled X(cs + [here], there);
    }

    adjoint invert; 
    controlled adjoint invert; 
}
```
In the example above, `adjoint invert;` indicates that the adjoint specialization is to be generated by inverting the body implementation, and `controlled adjoint invert;` indicates that the controlled adjoint specialization is to be generated by inverting the given implementation of the controlled specialization.

If one or more specializations besides the default body need to be explicitly declared, then the implementation for the default body needs to be wrapped into a suitable specialization declaration as well:

### Circumstances for validly defining specializations

#### Operation declarations with adjoint/controlled

It is legal to specify an operation with no adjoint or controlled versions. 
For instance, measurement operations have neither, because they are not invertible or controllable.

An operation supports the `Adjoint` and/or `Controlled` functors if its declaration contains an implicit or explicit declaration of the respective specializations.

An explicitly declared adjoint/controlled specialization implies the existence of an adjoint/controlled specialization. 

For an operation whose body contains repeat-until-success loops, set statements, measurements, return statements, or calls to other operations that do not support the `Adjoint` functor, auto-generating an adjoint specialization following the `invert` or `auto` directive is not possible.

For an operation whose body contains calls to other operations that does not support the `Controlled` functor, auto-generating a controlled specialization following the `distribute` or `auto` directive is not possible.

#### Controlled Adjoint

The controlled adjoint version of an operation specifies how a quantum-controlled version of the adjoint of the operation is implemented.
It is legal to specify an operation with no controlled adjoint version; for instance, measurement operations have no controlled adjoint version because they are neither controllable nor invertible.

A controlled adjoint specialization for an operation needs to exist if and only if both an adjoint and a controlled specialization exist. In that case, the existence of the controlled adjoint specialization is inferred and an appropriate specialization is generated by the compiler if no implementation has been defined explicitly. 

For an operation whose body contains calls to other operations that do not have a controlled adjoint version, auto-generating an adjoint specialization following the `invert`, `distribute` or `auto` directive is not possible.

